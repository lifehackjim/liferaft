#! Python packaging configuration file
# Python Packaging: https://packaging.python.org/en/latest/specifications/section-distribution-metadata/
# PEPs: https://peps.python.org/

[tool.rambling] #! Just a section with a lot of rambling notes
version = "0.1.0" # str, Version tracker for the tooling itself
changelog = """
- 0.1.0: Initial version
"""

file_structure = """
- src/           - source code for the package
- tests/         - tests for the package
- docs/          - documentation for the package
- artifacts/     - artifacts generated by building the package or running tests
- .cache/        - cache files generated by various tools
- .venv/         - virtual environments for the project, created by hatch
- mkdocs.toml    - configuration for the MkDocs documentation generator
- hatch.toml     - configuration for the hatch package manager
- ruff.toml      - configuration for the Ruff code checker and formatter
- pyproject.toml - configuration for the build system, project metadata, and tools that do not support their own TOML file
"""
implied_cognizance = """
While some developers comment their code carefully to explain what the code does, it is beyond rare to find a project where the configuration files are commented to explain what the configuration does.

This is a shame because the configuration is just as much "code" as the source code itself. It is the code that tells the tools how to build, test, and package the project. It is the code that tells the IDE how to provide the best guidance and feedback while coding. It is the code that tells the CI system how to build, test, and package the project in a CI environment.

This file and its companion TOML files contain all the configuration settings for the project's "scaffolding" - the structure and tools used to build, test, and package the project. Think of it as the project's exoskeleton! 🦴

The main types of scaffolding are:
- 📝 IDE: settings for your IDE to provide the best guidance and feedback while coding
- 💻 CLI: configurations for command-line tools used to build, test, check, format, and package the project
- 🛠️ COMMIT: settings for tools that check and format code before committing to the repository
- 🚀 CI: configurations for tools used to build, test, and package the project in a CI environment
"""

[build-system] #! Build System Configuration https://www.python.org/dev/peps/pep-0517/#build-system-table
build-backend = "hatchling.build" # str, setuptools.build_meta:__legacy__, The Python object used to perform the build process.

requires = [
  #? list[str], [], The python package names (and optionally their versions) required to build the project.
  "hatchling >= 1.22.4", # https://github.com/pypa/hatch/tree/master/backend
]
# backend-path = [] # list[str], [], The path to the backend module. This is used to specify the path to the build backend module when it is not in the same directory as the pyproject.toml file.

[project] #! Project Metadata https://packaging.python.org/specifications/core-metadata/#name
description = 'A developers tool belt to help you in Python infested waters.' # str, A brief description of the project.

name = "liferaft"                  # str, The name of the project.
requires-python = ">=3.10"         # str, Minimum python version for the project.
readme = "README.md"               # str, The file path to the project's README file.
license = { file = "LICENSE.txt" } # str|dict, "", License string or path to license file
# version, str, "", The version of the project as supported by PEP 440.

dynamic = [
  #? list[str], [], Project settings that are dynamically managed by the build backend.
  "version", # controlled by hatch.toml:[version]
]
authors = [
  #? list[dict[str, str]], [], Authors who contributed to the project.
  { name = "Jim Olsen", email = "jim@lifehack.com" },
]
maintainers = [
  #? list[dict[str, str]], [], Maintainers who are responsible for the project.
  { name = "Jim Olsen", email = "jim@lifehack.com" },
]
keywords = [
  #? list[str], [], Keywords to help users discover the project.
  "debugging",
  "developer-tools",
  "development",
  "devops",
  "open-source",
  "programming",
  "python",
  "scripting",
  "software-development",
  "toolbelt",
  "utilities",
]
classifiers = [
  #? list[str], [], PyPI classifiers that help users discover the project https://pypi.org/classifiers/
  "Development Status :: 3 - Alpha",
  "Intended Audience :: Developers",
  "Operating System :: OS Independent",
  "Programming Language :: Python :: 3 :: Only",
  "Programming Language :: Python :: 3.10",
  "Programming Language :: Python :: 3.11",
  "Programming Language :: Python :: 3.12",
  "Programming Language :: Python :: Implementation :: CPython",
  "Programming Language :: Python :: Implementation :: PyPy",
  "Topic :: Utilities",
  "Topic :: Software Development :: Libraries :: Python Modules",
]
dependencies = [
  #? list[str], [], Python packages (and optionally their versions) required for the project to function properly.
  "pydantic >= 2.6.4", # https://github.com/pydantic/pydantic - data modeling & validation
]

# scripts = {} # dict[str, str], {}, CLI scripts to create when this package is installed
# gui-scripts = {} # dict[str, str], {}, Like `scripts`, but launch the script in the background. Only relevant on Windows.
# entry-points = {} # dict[str, dict[str, str]], {}, Entry points to create when this package is installed

[project.optional-dependencies] #! Extras to expose via `pip install package[extra1,extra2]`
watch = [
  #? dependency for watching files and running commands
  "watchfiles >= 0.21.0", # https://github.com/samuelcolvin/watchfiles/tree/main - Watch files and run commands when they change # TODO: Unsure if we want this to be a core dependency or an optional dependency
]
dev-debug = [
  #? dependencies for debuggin
  "rich >= 13.7.1",    # https://github.com/Textualize/rich - Rich text formatting for the terminal
  "pdbpp >= 0.10.3",   # https://github.com/pdbpp/pdbpp - Debugger with syntax highlighting and tab completion
  "icecream >= 2.1.3", # https://github.com/gruns/icecream - Debug with print() statements
]
dev-check = [
  #? dependencies for code checking and formatting
  "mypy[reports] >= 1.9.0", # https://github.com/python/mypy - Static type checker (conf:pyproject.toml) (extra:reports for lxml package for certain report types)
  "pyright >= 1.1.355",     # https://github.com/microsoft/pyright - Static type checker (conf:pyproject.toml)
  "fawltydeps >= 0.15.0",   # https://github.com/tweag/FawltyDeps - Detect dependency issues (conf:pyproject.toml)
  "ruff >= 0.3.4",          # https://github.com/astral-sh/ruff - Code checking and formatting tool (conf:ruff.toml)
  "coverage[toml] >= 7.4",  # https://github.com/nedbat/coveragepy - Generate reports on test coverage (conf:pyproject.toml) (extra:toml for tomli package for python 3.10 and below)
  "codespell >= 2.2.6",     # https://github.com/codespell-project/codespell - Spell checker for source code
]
dev-test = [
  #? dependencies for testing
  "coverage[toml] >= 7.4",         # https://github.com/nedbat/coveragepy - Generate reports on test coverage (conf:pyproject.toml) (extra:toml for tomli package for python 3.10 and below)
  "pytest >= 8.1.1",               # https://github.com/pytest-dev/pytest/ - Test runner (conf:pyproject.toml)
  "pytest-cov >= 5.0.0",           # https://github.com/pytest-dev/pytest-cov - Perform coverage during tests
  "pytest-pretty >= 1.2.0",        # https://github.com/samuelcolvin/pytest-pretty - Prettify test output
  "pytest-xdist[psutil] >= 3.5.0", # https://github.com/pytest-dev/pytest-xdist - Run tests in parallel (extra:psutil to use psutil for CPU count)
  "pytest-mock >= 3.14.0",         # https://github.com/pytest-dev/pytest-mock - Mocking with pytest
  "xdoctest >= 1.1.3",             # https://pypi.org/project/xdoctest/ - Extended doctests
]
dev-docs = [
  #? dependencies for documentation
  "mkdocs >= 1.5.3",           # https://github.com/mkdocs/mkdocs - Static site generator for project documentation (conf:mkdocs.yml)
  "mkdocs-material >= 9.5.16", # https://github.com/squidfunk/mkdocs-material - Material Design theme for MkDocs
  # TODO: docs dependencies from `hatch` itself
  # # Plugins
  # "mkdocs-minify-plugin => 0.7.1",                      # https://github.com/byrnereese/mkdocs-minify-plugin - Minify HTML, CSS, and JS
  # "mkdocs-git-revision-date-localized-plugin => 1.2.4", # https://github.com/timvink/mkdocs-git-revision-date-localized-plugin - Display the last git revision date of a file
  # "mkdocs-git-committers-plugin-2~=2.2.2",              # https://github.com/byrnereese/mkdocs-git-committers-plugin
  # "mkdocstrings-python~=1.7.5",
  # "mkdocs-redirects~=1.2.1",
  # "mkdocs-glightbox~=0.3.5",
  # "mike~=2.0.0",
  # # Extensions
  # "mkdocs-click~=0.8.1",
  # "pymdown-extensions~=10.5.0",
  # # Necessary for syntax highlighting in code blocks
  # "pygments~=2.17.2",
  # # Validation
  # # https://github.com/linkchecker/linkchecker/pull/669#issuecomment-1267236287
  # "linkchecker @ git+https://github.com/linkchecker/linkchecker.git@d9265bb71c2054bf57b8c5734a4825d62505c779",
]

[project.urls] #! Project URLs to display on PyPi
Homepage = "https://github.com/lifehackjim/liferaft"             # The URL of the project's homepage or main website.
Issues = "https://github.com/lifehackjim/liferaft/issues"        # The URL where users can report issues or bugs related to the project.
Source = "https://github.com/lifehackjim/liferaft"               # The URL where users can view the project's source code.
Sponsor = "https://github.com/sponsors/lifehackjim"              # TODO: # The URL where users can sponsor the project or make financial contributions.
Documentation = "https://github.com/lifehackjim/liferaft#readme" # TODO: # The URL of the project's documentation.

[tool.codespell] #! Codespell Configuration https://github.com/codespell-project/codespell?tab=readme-ov-file#using-a-config-file
builtin = "clear,rare,informal,usage,code,names" # str, "", clear|rare|informal|usage|code|names|en-GB_to_en-US, CSV of builtin dictionaries to use.
ignore-words-list = "master,crate"               # str, "", CSV of words to ignore.
skip = "artifacts,.cache,.venv"                  # str, "", CSV of files to skip.

# exclude-file, str, null, Ignore whole lines that match those in the file. The lines in file should match the to-be-excluded lines exactly
# ignore-regex, str, null, A regular expression to ignore when spell checking.
# ignore-words, str, null, File containing words to ignore.
# uri-ignore-words-list, str, "", CSV of words to ignore only in URI strings.

[tool.coverage.run] #! Coverage run configuration https://github.com/nedbat/coveragepy/blob/master/doc/config.rst
context = "${CONTEXT}"            # str, null, The static context to include in the coverage data.
data_file = "artifacts/.coverage" # str, .coverage, The file where coverage data is stored.
# command_line = "" # str, "", The command-line to run your program. This will be used if you run coverage run with no further arguments.
# debug_file = "" # str, "", File name to write debug output to.
# dynamic_context = "" # str, null, The name of a strategy for setting the dynamic context during execution. Can not use with pytest-cov as it sets its own dynamic context.

branch = true         # bool, false, Whether to measure branch coverage in addition to statement coverage.
cover_pylib = false   # bool, false, Whether to measure coverage of the Python standard library.
parallel = true       # bool, false, Append the machine name, process id and random number to the data file name to simplify collecting data from many processes. Ignored when using pytest_cov?
relative_files = true # bool, false, Store relative filenames in the data file.
# sigterm = false       # bool, false, Catch SIGTERM and write coverage data before exiting. Only for Linux and Mac.
# timid = false         # bool, false, Use a simpler but slower trace method.

omit = [
  #? list[str], [], File name patterns to omit from coverage measurement.
  # "src/*/__about__.py", # not really needed
]
source = [
  #? list[str], [], File name patterns to include in measurement or reporting.
  "src/liferaft",
  "tests",
]
# concurrency = [] # list[str], thread, The concurrency models used in the projects code.
# debug = [] # list[str], [], Debug options to enable.
# disable_warnings = [] # list[str], [], Warnings to disable.
# include = [] # list[str], [], File name patterns to include in measurement or reporting. Ignored if source is set.
# plugins = [] # list[str], [], Plugin package names.
# source_pkgs = [] # list[str], [], Only measure test coverage for specific package names.

# paths = {} # dict[str, list[str]], {}, Path mapping for combining data from different machines.

[tool.coverage.report] #! Coverage report configuration
sort = "Miss" # str, Name, Name|Stmts|Miss|Branch|BrPart|Cover, The order in which to sort the files in the report. Prefix with - for descending sort.

precision = 2 # int, 0, The number of decimal places to display for percentages.
# fail_under, float, null, Exit with status code of 2 if the total coverage is less than this value.

ignore_errors = false              #  bool, false, Ignore source code that can’t be found, emitting a warning instead of an exception.
show_missing = true                # bool, false, Show missing lines in the report.
skip_covered = true                # bool, false, When running a summary report, skip files with 100% coverage.
skip_empty = true                  # bool, false, When running a summary report, skip files with no statements.
include_namespace_packages = false # bool, false, When searching for unexecuted files, include directories without __init__.py files in the report.

exclude_also = [
  #? list[str], [], Patterns to add to exclude_lines.
  "no cov",                    # skip coverage with # no cov
  "if TYPE_CHECKING:",         # skip coverage of type checking blocks
  "raise NotImplementedError", # skip coverage of NotImplementedError
  "raise AssertionError",      # skip coverage of AssertionError
]
# exclude_lines = [] # list[str], [], Lines containing these strings are excluded from the report.
# include = [] # list[str], [], File name patterns to include in the report.
# omit = [] # list[str], [], File name patterns to omit from the report.
# partial_branches = [] # list[str], ["pragma: no branch"], Any line of code that matches one of these regexes is excused from being reported as a partial branch.

[tool.coverage.html] #! Coverage HTML report configuration
directory = "artifacts/coverage_html" # str, htmlcov, Where to write the HTML report files.
# extra_css = "" # str, "", Path to a CSS file to include in the HTML report. Do not use style.css
# title = "" # str, Coverage report, The title of the HTML report.
show_contexts = true # bool, false, Show contexts in the HTML report.
skip_covered = false # bool, false, When running a summary report, skip files with 100% coverage.
skip_empty = false   # bool, false, When running a summary report, skip files with no statements.

[tool.coverage.xml] #! Coverage XML report configuration
output = "artifacts/coverage.xml" # str, coverage.xml, Where to write the XML report file.
# package_depth = 99 # int, 99, The depth of package names to include in the XML report.

[tool.coverage.json] #! Coverage JSON report configuration
output = "artifacts/coverage.json" # str, coverage.json, Where to write the JSON report file.
pretty_print = true                # bool, false, Pretty print the JSON report.
show_contexts = true               # bool, false, Show contexts in the JSON report.

[tool.pytest.ini_options] #! Pytest Configuration https://docs.pytest.org/en/latest/customize.html
cache_dir = ".cache/.pytest_cache" # str, .pytest_cache, The directory where pytest stores its cache files.
console_output_style = "count"     # str, classic, classic|progress|progress-even-when-capture-no|count, The style of console output to use.
empty_parameter_set_mark = "xfail" # str, skip, skip|xfail|fail_at_collect, Action for empty parametersets in parameterization
log_cli_level = "INFO"             # str, WARNING, NOTSET|DEBUG|INFO|WARNING|ERROR|CRITICAL, The log level to use for console output.
log_file = "artifacts/pytest.log"  # str, null, The file to write log messages to.
log_file_level = "DEBUG"           # str, WARNING, NOTSET|DEBUG|INFO|WARNING|ERROR|CRITICAL, The log level to use for file output.
minversion = "8.1.1"               # str, "", The minimum version of pytest required to run the tests.

log_file_format = "%(asctime)s %(levelname)-8s [%(name)s:%(funcName)s:%(pathname)s:%(lineno)d] %(message)s" # str, "%(asctime)s %(levelname)s %(message)s", The format of log messages for the log file.
# doctest_encoding = "utf-8" # , str, "utf-8", The encoding to use when running doctests.
# junit_duration_report = "total" # str, "total", The duration to report in JUnit XML files. total=setup+call+teardown; call=call
# junit_family = "xunit2" # str, "xunit2", The format of the JUnit XML files.
# junit_logging = "all" # str, "no", log|system-out|system-err|out-err|all|no, Configures if captured output should be written to the JUnit XML file.
# junit_suite_name = "pytest" # str, "pytest", The name of the test suite to report in the JUnit XML files.
# log_cli_date_format = "" # str, "%Y-%m-%d %H:%M:%S", Console log date format
# log_cli_format = "" # str, "%(asctime)s %(levelname)s %(message)s", Console log format
# log_file_date_format = "" # str, "%Y-%m-%d %H:%M:%S", File log date format
# testpaths = "" # str, null, Directories that should be searched for tests when no user supplied targets are given.
# tmp_path_retention_policy = "" # str, "all", [all|failed|none], Policy for retaining tmp_path directories.

# faulthandler_timeout = 5 # int, null, Dump a traceback of all threads if a test takes longer than this many seconds. Does not work on windows.
# tmp_path_retention_count = 3 # int, 3, Number of sessions to keep tmp_path directories for.
# verbosity_assertions = 0 # int, 0, The verbosity level for assertion introspection output.
# verbosity_test_cases = 0 # int, 0, The verbosity level for test case introspection output.

consider_namespace_packages = false # bool, false, Include namespace packages when collecting Python modules.
log_auto_indent = true              # bool|int, false, Enable auto-indentation in log messages
log_cli = false                     # bool, false, Enable log output to console.
xfail_strict = true                 # bool, false, Fail tests marked with @pytest.mark.xfail that actually succeed

addopts = [
  #? str|list[str], [], Additional command-line options to pass to pytest every time it is run.
  "--strict-config",  # Any config warnings encountered raise errors
  "--strict-markers", # Markers not in the `markers` section raise errors
  "--durations=5",    # Show the 5 slowest tests
  "--xdoctest",       # Use the xdoctest style for doctests
]
required_plugins = [
  #? list[str], [], Plugins that must be installed for pytest to run.
  "pytest-cov",
  "pytest-xdist",
  "pytest-mock",
]
filterwarnings = [
  #? list[str], [], Warnings to filter and the action to take for each warning.
  "error",                     # error for all warnings anywhere in the code
  "error::DeprecationWarning", # error for all DeprecationWarnings
]
markers = [
  #? list[str], [], Markers that are allowed to be used in tests.
  "slow: marks tests as slow (deselect with -m 'not slow')",
]

# doctest_optionflags = [] # list[str], [], Global doctest option flags https://docs.python.org/3/library/doctest.html#option-flags
# norecursedirs = [] # list[str], ['*.egg', '.*', '_darcs', 'build', 'CVS', 'dist', 'node_modules', 'venv', '{arch}'], Directories to avoid when looking for tests.
# python_classes = [] # list[str], ["Test"], Patterns to match class names against when looking for tests.
# python_files = [] # list[str], ["test_*.py", "*_test.py"], Patterns to match file names against when looking for tests.
# python_functions = [] # list[str], ["test_*"], Patterns to match function names against when looking for tests.
# pythonpaths = [] # list[str], [], Additional directories to add to the PYTHONPATH environment variable.
# usefixtures = [] # list[str], [], List of fixtures that will be applied to all test functions.

[tool.fawltydeps] #! FawltyDeps Configuration https://github.com/tweag/FawltyDeps/blob/main/README.md#configuration
output_format = 'human_detailed' # str, human_summary, human_summary|human_detailed|json, The format to use for output.
# deps_parser_choice = ""  # str, null, null|requirements.txt|setup.py|setup.cfg|pyproject.toml, Manually select which format to use for parsing declared dependencies.

# verbosity = 0  # int, 0, -2|-1|0|1|2, Control log level. Default is WARNING and above

install_deps = false # bool, false, Allow FawltyDeps to `pip install` declared dependencies into a separate temporary virtualenv to discover the imports they expose.

exclude = [
  #? list[str], [], Path patterns to exclude when looking for code (imports), dependency declarations and/or Python environments.
  '.*',
  'artifacts',
]
ignore_unused = [
  #? list[str], ['autopep8', 'bandit', 'black', 'codespell', 'coverage', 'fawltydeps', 'flake8', 'isort', 'mccabe', 'mypy', 'myst-parser', 'nox', 'pre-commit', 'pydocstyle', 'pyflakes', 'pyformat', 'pylint', 'pyright', 'pytest', 'recommonmark', 'rope', 'ruff', 'sphinx', 'tox', 'twine', 'unify', 'wheel', 'yapf'], Dependencies to ignore when looking for unused dependencies.
  "mypy",
  "pyright",
  "fawltydeps",
  "ruff",
  "coverage",
  "rich",
  "pdbpp",
  "icecream",
  "pytest",
  "pytest-cov",
  "pytest-pretty",
  "pytest-xdist",
  "pytest-mock",
  "mkdocs",
  "mkdocs-material",
  "codespell",
  "xdoctest",
  # TODO: remove me later when we figure out how to handle the features in hatch env's
  "watchfiles", # for now this lets hatch run check pass
]
# actions = [] # list[str], ['check_undeclared', 'check_unused'], list_imports|list_deps|check_undeclared|check_unused, Actions to perform
# code = [] # list[str], ["."], Files or directories containing the code to parse for import statements.
# deps = [] # list[str], ["."], Files or directories containing the declared dependencies.
# pyenvs = [] # list[str], ["."], Where to search for Python environments that have project dependencies installed.
# ignore_undeclared = [] # list[str], [], Imports to ignore when looking for undeclared dependencies.
# custom_mapping_file = [] # list[str], [], Paths to TOML files containing mapping of dependencies to imports defined by the user.

# custom_mapping = {} # dict[str, str], {}, Mapping of dependencies to imports defined by the user.

[tool.mypy] #! Mypy Configuration https://mypy.readthedocs.io/en/stable/config_file.html
cache_dir = ".cache/.mypy_cache" # str, .mypy_cache, The directory where mypy stores its cache files.
follow_imports = "normal"        # str, normal, normal|silent|skip|error, What to do with imports when the imported module is found as a .py file and not part of the files, modules and packages provided on the command line.
plugins = "pydantic.mypy"        # str, "", A CSV of plugins to enable.

# any_exprs_report = ""     # str, "", Causes mypy to generate a text file report documenting how many expressions of type Any are present within your codebase. Not recommended for global config due to performance implications.
# cobertura_xml_report = "" # str, "", Causes mypy to generate a Cobertura XML type checking coverage report. Not recommended for global config due to performance implications.
# custom_typeshed_dir = ""  # str, "", This specifies the directory where mypy looks for standard library typeshed stubs, instead of the typeshed that ships with mypy.
# custom_typing_module = "" # str, "", Specifies a custom module to use as a substitute for the typing module.
# files = ""                # str, "", Files to check if none are supplied by user.
# html_report = ""          # str, "", Causes mypy to generate an HTML type checking coverage report. Not recommended for global config due to performance implications. Requires the `lxml` package or `mypy[reports]` extra.
# junit_xml = ""            # str, "", Causes mypy to generate a JUnit XML test result document with type checking results. This can make it easier to integrate mypy with continuous integration (CI) tools. Not recommended for global config due to situation-specific nature.
# linecount_report = ""     # str, "", Causes mypy to generate a text file report documenting the functions and lines that are typed and untyped within your codebase. Not recommended for global config due to performance implications.
# linecoverage_report = ""  # str, "", Causes mypy to generate a JSON file that maps each source file's absolute filename to a list of line numbers that belong to typed functions in that file. Not recommended for global config due to performance implications.
# lineprecision_report = "" # str, "", Causes mypy to generate a flat text file report with per-module statistics of how many lines are typechecked etc. Not recommended for global config due to performance implications.
# modules = ""              # str, "", Modules to check if none are supplied by user.
# platform = ""             # str, $sys.platform [darwin|win32|linux], Specifies the OS platform for the target program.
# python_executable = ""    # str, "", Specifies the path to the Python executable to inspect to collect a list of available PEP 561 packages. User home directory and environment variables will be expanded.
# python_version = ""       # str, "", Specifies the Python version used to parse and check the target program.
# txt_report = ""           # str, "", Causes mypy to generate a text file type checking coverage report. Not recommended for global config due to performance implications. Requires the `lxml` package or `mypy[reports]` extra.
# xml_report = ""           # str, "", Causes mypy to generate an XML type checking coverage report. Not recommended for global config due to performance implications. Requires the `lxml` package or `mypy[reports]` extra.

verbosity = 0 # int, 0, 0|1|2|3|4|5, Controls how much debug output will be generated. Higher numbers are more verbose.

strict = true                      #* bool, false, This is a special setting that sets a bunch of other settings to specific values.Sets: check_untyped_defs=true, disallow_any_generics=true, disallow_incomplete_defs=true, disallow_subclassing_any=true, disallow_untyped_calls=true, disallow_untyped_decorators=true, disallow_untyped_defs=true, implicit_reexport=false, strict_equality=true, warn_redundant_casts=true, warn_return_any=true, warn_unused_configs=true, warn_unused_ignores=true
allow_redefinition = false         # bool, false, Allow variables to be redefined with an arbitrary type, as long as the redefinition is in the same block and nesting level as the original definition.
allow_untyped_globals = false      # bool, false, Allow untyped global variables and class variables.
cache_fine_grained = false         # bool, false, Include fine-grained dependency information in the cache for the mypy daemon.
check_untyped_defs = true          # bool, false, Check the interior of functions without type annotations.
color_output = true                # bool, false, Use colors in error messages.
disallow_any_decorated = true      # bool, false, Disallows functions that have Any in their signature after decorator transformation.
disallow_any_explicit = true       # bool, false, Disallows explicit Any in type positions such as type annotations and generic type parameters.
disallow_any_expr = true           # bool, false, Disallows all expressions in the module that have type Any.
disallow_any_generics = true       # bool, false, Disallows usage of generic types that do not specify explicit type parameters.
disallow_any_unimported = true     # bool, false, Disallows usage of types that come from unfollowed imports (anything imported from an unfollowed import is automatically given a type of Any).
disallow_incomplete_defs = true    # bool, false, Disallows defining functions with incomplete type annotations, while still allowing entirely unannotated definitions.
disallow_subclassing_any = true    # bool, false, Disallows subclassing built-in types that are not generic (e.g. List, Dict) with Any.
disallow_untyped_calls = true      # bool, false, Disallows calling functions without type annotations from functions with type annotations.
disallow_untyped_decorators = true # bool, false, Disallows decorating functions without type annotations with decorators that have type annotations.
disallow_untyped_defs = true       # bool, false, Disallows defining functions without type annotations or with incomplete type annotations (a superset of disallow_incomplete_defs).
error_summary = true               # bool, false, Shows a short summary line after error messages.
explicit_package_bases = false     # bool, false, This flag tells mypy that top-level packages will be based in either the current directory, or a member of the MYPYPATH environment variable or mypy_path config option. This option is only useful in the absence of __init__.py.
follow_imports_for_stubs = false   # bool, false, Whether to respect the follow_imports setting even for stub (.pyi) files.
force_union_syntax = false         # bool, false, Always use Union[] and Optional[] for union types in error messages (instead of the | operator), even on Python 3.10+.
force_uppercase_builtins = false   # bool, false, Always use List instead of list in error messages, even on Python 3.9+.
hide_error_codes = false           # bool, false, Hides error codes in error messages.
ignore_errors = false              # bool, false, Ignore all non-fatal errors.
ignore_missing_imports = false     # bool, false, Ignore all missing imports.
implicit_optional = false          # bool, false, Treat None as an implicit Optional in function signatures.
implicit_reexport = false          # bool, true, Allow implicit re-exporting of imported values.
incremental = true                 # bool, false, Enables incremental mode
local_partial_types = false        # bool, false, Disallows inferring variable type for None from two assignments in different scopes. This is always implicitly enabled when using the mypy daemon.
namespace_packages = false         #  bool, true, Enables PEP 420 style namespace packages.
no_silence_site_packages = false   # bool, false, Enables reporting error messages generated within installed packages (see PEP 561 for more details on distributing type information). Those error messages are suppressed by default, since you are usually not able to control errors in 3rd party code.
no_site_packages = false           # bool, false, Disables using type information in installed packages (see PEP 561). This will also disable searching for a usable Python executable.
pdb = false                        # bool, false, Invokes pdb on fatal error.
pretty = true                      # bool, false, Use visually nicer output in error messages: use soft word wrap, show source code snippets, and show error location markers.
raise_exceptions = false           # bool, false, Raise exception on fatal error.
scripts_are_modules = false        # bool, false, Makes script x become module x instead of __main__. This is useful when checking multiple scripts in a single run.
show_absolute_path = false         # bool, false, Show absolute paths to files.
show_column_numbers = true         # bool, false, Show column numbers in error messages.
show_error_context = true          # bool, false, Show some source code context with errors.
show_traceback = false             # bool, false, Shows traceback on fatal error.
skip_cache_mtime_checks = false    # bool, false, Skip cache internal consistency checks based on mtime.
skip_version_check = false         # bool, false, Skip version check for incremental cache.
sqlite_cache = false               # bool, false, Use a SQLite database to store the cache.
strict_concatenate = true          # bool, false, Make arguments prepended via Concatenate be truly positional-only.
strict_equality = true             # bool, false, Prohibit equality checks, identity checks, and container checks between non-overlapping types.
strict_optional = true             # bool, true, Disallow None in places where it doesn’t make sense: in variable and attribute types, function argument and return types, and in generic types.
warn_incomplete_stub = true        # bool, false, Warns about missing type annotations in typeshed. This is only relevant in combination with disallow_untyped_defs or disallow_incomplete_defs.
warn_no_return = true              # bool, true, Shows errors for missing return statements on some execution paths.
warn_redundant_casts = true        # bool, false, Warns about casting an expression to its inferred type.
warn_return_any = true             # bool, false, Shows a warning when returning a value with type Any from a function declared with a non- Any return type.
warn_unreachable = true            # bool, false, Shows a warning when encountering any code inferred to be unreachable or redundant after performing type analysis.
warn_unused_configs = true         # bool, false, Warns about per-module sections in the config file that do not match any files processed when invoking mypy.
warn_unused_ignores = true         # bool, false, Warns about unneeded # type: ignore comments.

# always_false = [] # str|list[str], "", Variables that mypy will treat as compile-time constants that are always false.
# always_true = [] # str|list[str], "", Variables that mypy will treat as compile-time constants that are always true.
# disable_error_code = [] # str|list[str], "", Allows disabling one or multiple error codes globally.
# enable_error_code = [] # str|list[str], "", Allows enabling one or multiple error codes globally.
# exclude = [] # str|list[str], "", A regular expression that matches file names, directory names and paths which mypy should ignore while recursively discovering files to check.
# mypy_path = [] # str|list[str], "", Paths to use, after trying the paths from MYPYPATH environment variable. Useful if you'd like to keep stubs in your repo, along with the config file.
# packages = [] # str|list[str], [], Packages to check if none are supplied by user.
# untyped_calls_exclude = [] # str|list[str], "", Selectively excludes functions and methods defined in specific packages, modules, and classes from action of disallow_untyped_calls.

# [[tool.mypy.overrides]] #! Mypy overrides for specific modules
# verbosity = 0 # int, -2, -2|-1|0|1|2, The verbosity level for the module(s).
# module = [] # str|list[str], null, The module(s) to apply the overrides to.

[tool.pydantic-mypy] #! Pydantic Mypy Configuration https://pydantic-docs.helpmanual.io/mypy_plugin/
init_forbid_extra = true             # bool, false, Unexpected inputs to `__init__` will raise errors even if `Config.extra` is not `'forbid'
init_typed = true                    # bool, false, Generate a typed `__init__` method.
warn_required_dynamic_aliases = true # bool, false, Warn if a required field is set to a dynamically-determined alias or alias generator with `Config.populate_by_name=False`

[tool.pyright] #! Pyright Configuration https://github.com/microsoft/pyright/blob/main/docs/configuration.md - This provides the strictest settings for VSCode:Pylance
typeCheckingMode = "strict"                   #* str, standard, off|basic|standard|strict, This is a special setting that sets a bunch of other settings to specific values. https://microsoft.github.io/pyright/#/configuration?id=diagnostic-settings-defaults
reportAbstractUsage = "error"                 # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for the attempted instantiate an abstract or protocol class or use of an abstract method.
reportArgumentType = "error"                  # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for argument type incompatibilities when evaluating a call expression.
reportAssertAlwaysTrue = "error"              # bool|str, typeCheckingMode(off="none"|basic="warning"|standard="warning"|strict="error"), Diagnostics for assert statement that will probably always assert.
reportAssertTypeFailure = "error"             # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for a type mismatch detected by the typing.assert_type call
reportAssignmentType = "error"                # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for assignment type incompatibility
reportAttributeAccessIssue = "error"          # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics related to attribute accesses.
reportCallInDefaultInitializer = "error"      # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="none"), Diagnostics for function calls, list expressions, set expressions, or dictionary expressions within a default value initialization expression. Such calls can mask expensive operations that are performed at module initialization time.
reportCallIssue = "error"                     # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics related to call expressions and arguments passed to a call target.
reportConstantRedefinition = "error"          # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for attempts to redefine variables whose names are all-caps with underscores and numerals.
reportDeprecated = "error"                    # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for use of a class or function that has been marked as deprecated.
reportDuplicateImport = "error"               # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for an imported symbol or module that is imported more than once.
reportFunctionMemberAccess = "error"          # bool|str, typeCheckingMode(off="none"|basic="none"|standard="error"|strict="error"), Diagnostics for non-standard member accesses for functions.
reportGeneralTypeIssues = "error"             # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for general type inconsistencies, unsupported operations, argument/parameter mismatches, etc. This covers all of the basic type-checking rules not covered by other rules. It does not include syntax errors.
reportImplicitOverride = "error"              # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="none"), Diagnostics for overridden methods in a class that are missing an explicit @override decorator.
reportImplicitStringConcatenation = "error"   # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="none"), Diagnostics for two or more string literals that follow each other, indicating an implicit concatenation. This is considered a bad practice and often masks bugs such as missing commas.
reportImportCycles = "error"                  # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="none"), Diagnostics for cyclical import chains. These are not errors in Python, but they do slow down type analysis and often hint at architectural layering issues. Generally, they should be avoided. Note that there are import cycles in the typeshed stdlib typestub files that are ignored by this setting.
reportIncompatibleMethodOverride = "error"    # bool|str, typeCheckingMode(off="none"|basic="none"|standard="error"|strict="error"), Diagnostics for method overrides that are incompatible with the overridden method.
reportIncompatibleVariableOverride = "error"  # bool|str, typeCheckingMode(off="none"|basic="none"|standard="error"|strict="error"), Diagnostics for class variable declarations that override a symbol of the same name in a base class with a type that is incompatible with the base class symbol type.
reportIncompleteStub = "error"                # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for a module-level __getattr__ call in a type stub file|indicating that it is incomplete.
reportInconsistentConstructor = "error"       # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics when an __init__ method signature is inconsistent with a __new__ signature.
reportInconsistentOverload = "error"          # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for an overloaded function that has overload signatures that are inconsistent with each other or with the implementation.
reportIndexIssue = "error"                    # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for indexing operations that are inconsistent with the type of the object being indexed.
reportInvalidStringEscapeSequence = "error"   # bool|str, typeCheckingMode(off="none"|basic="warning"|standard="warning"|strict="error"), Diagnostics for invalid escape sequences used within string literals. The Python specification indicates that such sequences will generate a syntax error in future versions.
reportInvalidStubStatement = "error"          # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for statements that are syntactically correct but have no purpose within a type stub file.
reportInvalidTypeArguments = "error"          # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for invalid type arguments in a type annotation.
reportInvalidTypeForm = "error"               # bool|str, typeCheckingMode(off="warning"|basic="error"|standard="error"|strict="error"), Diagnostics for type annotations that use invalid type expression forms or are semantically invalid.
reportInvalidTypeVarUse = "error"             # bool|str, typeCheckingMode(off="none"|basic="warning"|standard="warning"|strict="error"), Diagnostics for when a TypeVar is used inappropriately (e.g. if a TypeVar appears only once) within a generic function signature.
reportMatchNotExhaustive = "error"            # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for a match statement that does not provide cases that exhaustively match against all potential types of the target expression.
reportMissingImports = "error"                # bool|str, typeCheckingMode(off="warning"|basic="error"|standard="error"|strict="error"), Diagnostics for imports that have no corresponding imported python file or type stub file.
reportMissingModuleSource = "error"           # bool|str, typeCheckingMode(off="warning"|basic="warning"|standard="warning"|strict="warning"), Diagnostics for imports that have no corresponding source file. This happens when a type stub is found, but the module source file was not found, indicating that the code may fail at runtime when using this execution environment. Type checking will be done using the type stub.
reportMissingParameterType = "error"          # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for input parameters for functions or methods that are missing a type annotation. The self and cls parameters used within methods are exempt from this check.
reportMissingSuperCall = "error"              # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="none"), Diagnostics for __init__, __init_subclass__, __enter__ and __exit__ methods in a subclass that fail to call through to the same-named method on a base class.
reportMissingTypeArgument = "error"           # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics when a generic class is used without providing explicit or implicit type arguments.
reportMissingTypeStubs = "error"              # bool|str, typeCheckingMode(off="none"|basic="warning"|standard="warning"|strict="error"), Diagnostics for imports that have no corresponding type stub file (either a typeshed file or a custom type stub). The type checker requires type stubs to do its best job at analysis. Note that there is a corresponding quick fix for this diagnostics that let you generate custom type stub to improve editing experiences.
reportNoOverloadImplementation = "error"      # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for an overloaded function or method if the implementation is not provided
reportOperatorIssue = "error"                 # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics related to the use of unary or binary operators (like * or not).
reportOptionalCall = "error"                  # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for an attempt to call a variable with an Optional type.
reportOptionalContextManager = "error"        # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for an attempt to use an Optional type as a context manager (as a parameter to a with statement).
reportOptionalIterable = "error"              # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for an attempt to use an Optional type as an iterable value (e.g. within a for statement).
reportOptionalMemberAccess = "error"          # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for an attempt to access a member of a variable with an Optional type.
reportOptionalOperand = "error"               # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for an attempt to use an Optional type as an operand to a unary operator (like ~ or not) or the left-hand operator of a binary operator (like *, ==, or).
reportOptionalSubscript = "error"             # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for an attempt to subscript (index) a variable with an Optional type.
reportOverlappingOverload = "error"           # bool|str, typeCheckingMode(off="none"|basic="none"|standard="error"|strict="error"), Diagnostics for function overloads that overlap in signature and obscure each other or have incompatible return types.
reportPossiblyUnboundVariable = "error"       # bool|str, typeCheckingMode(off="none"|basic="none"|standard="error"|strict="error"), Diagnostics for variables that are possibly unbound on some code paths.
reportPrivateImportUsage = "error"            # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for use of a symbol from a "py.typed" module that is not meant to be exported from that module.
reportPrivateUsage = "error"                  # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for incorrect usage of private or protected variables or functions. Protected class members begin with a single underscore (“_”) and can be accessed only by subclasses. Private class members begin with a double underscore but do not end in a double underscore and can be accessed only within the declaring class. Variables and functions declared outside of a class are considered private if their names start with either a single or double underscore, and they cannot be accessed outside of the declaring module.
reportPropertyTypeMismatch = "error"          # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="none"), Diagnostics for properties where the type of the value passed to the setter is not assignable to the value returned by the getter. Such mismatches violate the intended use of properties, which are meant to act like variables.
reportRedeclaration = "error"                 # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for a symbol that has more than one type declaration.
reportReturnType = "error"                    # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics related to function return type compatibility.
reportSelfClsParameterName = "error"          # bool|str, typeCheckingMode(off="none"|basic="warning"|standard="warning"|strict="error"), Diagnostics for a missing or misnamed “self” parameter in instance methods and “cls” parameter in class methods. Instance methods in metaclasses (classes that derive from “type”) are allowed to use “cls” for instance methods.
reportShadowedImports = "error"               # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="none"), Diagnostics for files that are overriding a module in the stdlib.
reportTypeCommentUsage = "error"              # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for type comments that are used in a way that is not required for compatibility with the specified language version.
reportTypedDictNotRequiredAccess = "error"    # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for an attempt to access a non-required field within a TypedDict without first checking whether it is present.
reportUnboundVariable = "error"               # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for unbound variables.
reportUndefinedVariable = "error"             # bool|str, typeCheckingMode(off="warning"|basic="error"|standard="error"|strict="error"), Diagnostics for undefined variables.
reportUnhashable = "error"                    # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for the use of an unhashable object in a container that requires hashability.
reportUninitializedInstanceVariable = "error" # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="none"), Diagnostics for instance variables within a class that are not initialized or declared within the class body or the __init__ method.
reportUnknownArgumentType = "error"           # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for call arguments for functions or methods that have an unknown type.
reportUnknownLambdaType = "error"             # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for input or return parameters for lambdas that have an unknown type.
reportUnknownMemberType = "error"             # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for class members that have an unknown type.
reportUnknownParameterType = "error"          # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for input parameters for functions or methods that have an unknown type.
reportUnknownVariableType = "error"           # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for variables that have an unknown type.
reportUnnecessaryCast = "error"               # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for cast calls that are statically determined to be unnecessary. Such calls are sometimes indicative of a programming error.
reportUnnecessaryComparison = "error"         # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for == or != comparisons or other conditional expressions that are statically determined to always evaluate to false or true. Such comparisons are sometimes indicative of a programming error.
reportUnnecessaryContains = "error"           # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for in operations that are statically determined to always evaluate to false or true. Such operations are sometimes indicative of a programming error.
reportUnnecessaryIsInstance = "error"         # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for isinstance or issubclass calls where the result is statically determined to be always true. Such calls are often indicative of a programming error.
reportUnnecessaryTypeIgnoreComment = "error"  # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="none"), Diagnostics for a # type: ignore or # pyright: ignore comment that would have no effect if removed.
reportUnsupportedDunderAll = "error"          # bool|str, typeCheckingMode(off="none"|basic="warning"|standard="warning"|strict="error"), Diagnostics for statements that define or manipulate __all__ in a way that is not allowed by a static type checker, thus rendering the contents of __all__ to be unknown or incorrect. Also reports names within the __all__ list that are not present in the module namespace.
reportUntypedBaseClass = "error"              # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for base classes whose type cannot be determined statically. These obscure the class type, defeating many type analysis features.
reportUntypedClassDecorator = "error"         # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for class decorators that have no type annotations. These obscure the class type, defeating many type analysis features.
reportUntypedFunctionDecorator = "error"      # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for function decorators that have no type annotations. These obscure the function type, defeating many type analysis features.
reportUntypedNamedTuple = "error"             # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics when “namedtuple” is used rather than “NamedTuple”. The former contains no type information, whereas the latter does.
reportUnusedCallResult = "error"              # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="none"), Diagnostics for call statements whose return value is not used in any way and is not None.
reportUnusedClass = "error"                   # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for a class with a private name (starting with an underscore) that is not accessed.
reportUnusedCoroutine = "error"               # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for call statements whose return value is not used in any way and is a Coroutine. This identifies a common error where an await keyword is mistakenly omitted.
reportUnusedExcept = "error"                  # bool|str, typeCheckingMode(off="none"|basic="error"|standard="error"|strict="error"), Diagnostics for an except clause that will never be reached.
reportUnusedExpression = "error"              # bool|str, typeCheckingMode(off="none"|basic="warning"|standard="warning"|strict="error"), Diagnostics for simple expressions whose results are not used in any way.
reportUnusedFunction = "error"                # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for a function or method with a private name (starting with an underscore) that is not accessed.
reportUnusedImport = "error"                  # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for an imported symbol that is not referenced within that file.
reportUnusedVariable = "error"                # bool|str, typeCheckingMode(off="none"|basic="none"|standard="none"|strict="error"), Diagnostics for a variable that is not accessed. Variables whose names begin with an underscore are exempt from this check.
reportWildcardImportFromLibrary = "error"     # bool|str, typeCheckingMode(off="none"|basic="warning"|standard="warning"|strict="error"), Diagnostics for a wildcard import from an external library. The use of this language feature is highly discouraged and can result in bugs when the library is updated.

# pythonPlatform = "" # , str, $current_platform [Windows|Darwin|Linux|All], Specifies the target platform that will be used to execute the source code. If specified, pyright will tailor its use of type stub files, which conditionalize type definitions based on the platform
# pythonVersion = ""  # , str, $current_python_version, Specifies the version of Python that will be used to execute the source code. Controls the python version and type stubs that pyright uses
# stubPath = ""       # , str, "./typings", Path to a directory that contains custom type stubs. Each package's type stub file(s) are expected to be in its own subdirectory
# typeshedPath = ""   # , str, null, Path to a directory that contains typeshed type stub files. Pyright ships with a bundled copy of typeshed type stubs. If you want to use a different version of typeshed stubs, you can clone the typeshed github repo to a local directory and reference the location with this path
# venv = ""           # , str, null, Used in conjunction with the venvPath, specifies the virtual environment to use
# venvPath = ""       # , str, null, Path to a directory containing one or more subdirectories, each of which contains a virtual environment. When used in conjunction with a venv setting, pyright will search for imports in the virtual environment’s site-packages directory rather than the paths specified by the default Python interpreter

analyzeUnannotatedFunctions = true # bool, typeCheckingMode(off=true|basic=true|standard=true|strict=true), Analyze and report errors for functions and methods that have no type annotations for input parameters or return types.
deprecateTypingAliases = true      # bool, typeCheckingMode(off=true|basic=true|standard=true|strict=true), PEP 585 indicates that aliases to types in standard collections that were introduced solely to support generics are deprecated as of Python 3.9. This switch controls whether these are treated as deprecated. This applies only when pythonVersion is 3.9 or newer.
disableBytesTypePromotions = true  # bool, typeCheckingMode(off=true|basic=true|standard=true|strict=true), Disables legacy behavior where bytearray and memoryview are considered subtypes of bytes. PEP 688 deprecates this behavior, but this switch is provided to restore the older behavior.
enableExperimentalFeatures = false # bool, typeCheckingMode(off=false|basic=false|standard=false|strict=false), Enables a set of experimental (mostly undocumented) features that correspond to proposed or exploratory changes to the Python typing standard. These features will likely change or be removed, so they should not be used except for experimentation purposes.
enableTypeIgnoreComments = true    # bool, typeCheckingMode(off=true|basic=true|standard=true|strict=true), PEP 484 defines support for "# type: ignore" comments. This switch enables or disables support for these comments. This does not affect "# pyright: ignore" comments.
strictDictionaryInference = true   # bool, typeCheckingMode(off=true|basic=true|standard=true|strict=true), When inferring the type of a dictionary's keys and values, use strict type assumptions. For example, the expression {'a': 1, 'b': 'a'} could be inferred to be of type dict[str, Any] or dict[str, int | str]. If this setting is true, it will use the latter (stricter) type.
strictListInference = true         # bool, typeCheckingMode(off=true|basic=true|standard=true|strict=true), When inferring the type of a list, use strict type assumptions. For example, the expression [1, 'a', 3.4] could be inferred to be of type list[Any] or list[int | str | float]. If this setting is true, it will use the latter (stricter) type.
strictParameterNoneValue = true    # bool, typeCheckingMode(off=true|basic=true|standard=true|strict=true), PEP 484 indicates that when a function parameter is assigned a default value of None, its type should implicitly be Optional even if the explicit type is not. When enabled, this rule requires that parameter type annotations use Optional explicitly in this case.
strictSetInference = true          # bool, typeCheckingMode(off=true|basic=true|standard=true|strict=true), When inferring the type of a set, use strict type assumptions. For example, the expression {1, 'a', 3.4} could be inferred to be of type set[Any] or set[int | str | float]. If this setting is true, it will use the latter (stricter) type.
useLibraryCodeForTypes = true      # bool, true, Determines whether pyright reads, parses and analyzes library code to extract type information in the absence of type stub files. Type information will typically be incomplete. We recommend using type stubs where possible.
verboseOutput = true               # bool, false, Whether output logs should be verbose.

# exclude = [] # list[str], ["**/node_modules", "**/__pycache__", "**/.*"], Paths to exclude from the type checking process
# extraPaths = [] # list[str], [], Additional paths that will be used when searching for modules imported by files
# ignore = [] # list[str], [], Paths to ignore from the type checking process
# include = [] # list[str], ["."], Paths to include in the type checking process
# strict = [] # list[str], [], Paths to apply strict type checking. Same as adding "# pyright: strict" comment to the top of the file

# defineConstants = {} # dict[str, str|bool], {}, Identifiers that should be assumed to contain a constant value wherever used within this program
# executionEnvironments = [] # list[dict[str, any]], [], Execution environments are searched from start to finish by comparing the path of a source file with the root path specified in the execution environment
